#!/bin/sh
############################################################ IDENT(1)
#
# $Title: Script to generate top-like statistics for BeeGFS I/O $
# $Copyright: 2020 Devin Teske. All rights reserved. $
# $FrauBSD: beegfstop/beegfstop 2020-05-03 13:13:50 -0700 freebsdfrau $
#
############################################################ INFORMATION
#
# In beegfstop, a ``view'' is the user's choice between -c, -s, or -u.
# For example, `-u' asks beegfstop to display the ``user view'' where statistics
# displayed are on a per-user basis.
#
# The code is broken down into:
# 	- View selection (user choice)
# 	- Inspection of running system
# 	- beegfs-ctl execution
# 	- awk to process beegfs-ctl output
#
# Code navigating Search Terms/ST:
# 	CTLDATA		beegfs-ctl data generation and processing
# 	JSONDATA	JSON data generation
# 	OPS		Data operations (read vs write)
# 	POST		beegfs-ctl post-processor (awk)
# 	PRE		Start of pre-processor (sh)
# 	VIEWDATA	View data generation
# 	VIEWS		View processing
#
############################################################ DEFAULTS

DEFAULT_INTERVAL=2 # seconds

############################################################ GLOBALS

VERSION='$Version: 2.1 $'

pgm="${0##*/}" # Program basename

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
COLOR=					# -C
INTERVAL=$DEFAULT_INTERVAL		# -i sec
NO_NAMES=				# -n
NSAMPLES=				# -N num
OUTPUT_JSON=				# -j
RAW_VIEW=				# -r
VIEW_CLIENT=				# -c
VIEW_SERVER=				# -s
VIEW_USER=				# -u (default)
WIDE_VIEW=				# -w

#
# Miscellaneous
#
CONS=1
VIEW=

############################################################ FUNCTIONS

die()
{
	local fmt="$1"
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@" >&2
	fi
	exit $FAILURE
}

usage()
{
	local fmt="$1"
	local optfmt="\t%-11s %s\n"

	exec >&2
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@"
	fi

	printf "Usage: %s [OPTIONS]\n" "$pgm"
	printf "Options:\n"
	printf "$optfmt" "-C" "Always enable color."
	printf "$optfmt" "-c" "View read/write activity by client."
	printf "$optfmt" "-h" "Print usage statement and exit."
	printf "$optfmt" "-i sec" \
		"Set interval seconds. Default $DEFAULT_INTERVAL."
	printf "$optfmt" "-j" "Output JSON formatted data."
	printf "$optfmt" "-N num" "Perform num samples and exit."
	printf "$optfmt" "-n" "Do not attempt to map uid/gid/ip to names."
	printf "$optfmt" "-r" "Raw view. Do not format output of bpftrace."
	printf "$optfmt" "-s" "View read/write activity by server."
	printf "$optfmt" "-u" "View read/write activity by user (default)."
	printf "$optfmt" "-v" "Print version and exit."
	printf "$optfmt" "-w" "Wide view. Maximize width of first column."

	die
}

run_beegfs_ctl()
{
	set -- --nodetype=storage --interval=$INTERVAL "$@"
	[ "$NO_NAMES" ] || set -- --names "$@"
	if [ "$VIEW_CLIENT" ]; then
		set -- --clientstats --rwunit=B --perinterval "$@"
	elif [ "$VIEW_SERVER" ]; then
		set -- --serverstats --perserver "$@"
	elif [ "$VIEW_USER" ]; then
		set -- --userstats --rwunit=B --perinterval "$@"
	fi
	expect -f- strace -e trace=poll beegfs-ctl "$@" <<-'END-EXPECT' | awk '
		!/^(poll\(|\))/ { print; fflush(); next}
		sub(/^poll\(.*fd=0.*/, "---") { print; fflush() }
	' # END-AWK
		spawn {*}$argv
		while (1) {
			expect {
				-re "fd=0" { send_user "\n" }
				eof { exit 0 }
			}
		}
	END-EXPECT
}

############################################################ MAIN

#
# Process command-line options
#
while getopts Cchi:jN:nrsuvw flag; do
	case "$flag" in
	C) COLOR=1 ;;
	c) VIEW=CLIENT VIEW_CLIENT=1 ;;
	i) INTERVAL="$OPTARG" ;;
	j) OUTPUT_JSON=1 ;;
	N) [ "$OPTARG" ] || usage "-N option requires an argument" # NOTREACHED
		NSAMPLES="$OPTARG" ;;
	n) NO_NAMES=1 ;;
	r) RAW_VIEW=1 ;;
	s) VIEW=SERVER VIEW_SERVER=1 ;;
	u) VIEW=USER VIEW_USER=1 ;;
	v) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	w) WIDE_VIEW=1 ;;
	*) usage # NOTREACHED
	esac
done
shift $(( $OPTIND - 1 ))

#
# Process command-line arguments
#
[ $# -eq 0 ] || usage "Too many arguments" # NOTREACHED

#
# Silently ignore previous view options
#
[ "$VIEW" ] || VIEW=USER VIEW_USER=1
case "$VIEW" in
CLIENT) VIEW_SERVER= VIEW_USER= ;;
SERVER) VIEW_CLIENT= VIEW_USER= ;;
USER) VIEW_CLIENT= VIEW_SERVER= ;;
esac

#
# Process `-C' option
#
if [ "$COLOR" ]; then
	CONS=1
else
	[ -t 1 ] || CONS= # stdout is not a tty
fi

#
# Validate `-i sec' option
#
case "$INTERVAL" in
"") usage "missing -i argument" ;; # NOTREACHED
0) die "-i sec must be non-zero" ;;
*[!0-9]*) die "-i argument must be a number" ;;
esac

#
# Validate `-N num' option
#
case "$NSAMPLES" in
*[!0-9]*) die "-N num must be a positive integer" ;;
esac

#
# Get terminal size
#
size=$( stty size 2> /dev/null )
if [ "$size" ]; then
	cols="${size#*[$IFS]}"
	rows="${size%%[$IFS]*}"
	case "$rows$cols" in
	*[!0-9]*)
		cols=80
		rows=24
		;;
	esac
fi

#
# Run script
# ST: PRE
#
{
	run_beegfs_ctl
	echo EXIT:$?
} | awk -v cols=$cols \
	-v cons=${CONS:-0} \
	-v interval=$INTERVAL \
	-v no_names=${NO_NAMES:-0} \
	-v nsamples=${NSAMPLES:--1} \
	-v output_json=${OUTPUT_JSON:-0} \
	-v raw_view=${RAW_VIEW:-0} \
	-v rows=$rows \
	-v view="$VIEW" \
	-v wide_view=${WIDE_VIEW:-0} \
	'####################################### BEGIN

	# ST: POST

	BEGIN {
		exit_status = 0 # SUCCESS
		in_summary = 1
		samples_left = ++nsamples
		srand() # seed clock

		inv	= "\033[7m"
		noinv	= "\033[27m"
		bold    = "\033[1m"
		nobold  = "\033[22m"
		red     = "\033[31m"
		green   = "\033[32m"
		yellow  = "\033[33m"
		cyan    = "\033[36m"
		fgreset = "\033[39m"

		# Obtain current process (awk) pid
		(cmd = "echo $PPID") | getline apid
		close(cmd)

		# Obtain parent process (sh) pid
		getline stat < (file = sprintf("/proc/%d/stat", apid))
		close(file)
		split(stat, st)
		spid = st[4]

		# Obtain beegfs-ctl pid
		(cmd = sprintf("pgrep -P %d", spid)) | getline spid
		close(cmd)
		(cmd = sprintf("pgrep -P %d expect", spid)) | getline epid
		close(cmd)
		(cmd = sprintf("pgrep -P %d strace", epid)) | getline spid
		close(cmd)
		(cmd = sprintf("pgrep -P %d beegfs-ctl", spid)) | getline bpid
		close(cmd)

		#
		# Calculate columns and column widths
		#
		# NB: bar_size = size of bar column
		# NB: dsz = size of TOTAL, READ(IN), WRITE(OUT) data columns
		# NB: vsz = size of VIEW column ("view size")
		#
		# If given -w (wide view) make bar_size fixed-width and
		# vsz variable-width.
		#
		# Without -w, make vsz fixed-width and bar_size variable.
		#
		dsz = 12
		if (wide_view) {
			bar_size = 21
			vsz = cols - dsz * 3 - 4 - bar_size # Maximize view col
				#  4 = number of spaces
		} else {
			vsz = 15 # Maximize bar column
		}

		#
		# Calculate format and line width
		#
		fmt = ""
		fmtsz = 0
		fmt = fmt " %-" vsz "s" # VIEW column
		fmtsz += 1 + vsz
		fmt = fmt " %" dsz "s" # TOTAL column
		fmtsz += 1 + dsz
		if (cons) {
			fmt = fmt " " red "%" dsz "s" # WRITE(IN) column
		} else {
			fmt = fmt " %" dsz "s" # WRITE(IN) column
		}
		fmtsz += 1 + dsz
		bar_size = (cols - vsz - dsz * 3 - 4 - 1) / 2
			#  4 = number of spaces
			#  1 = balance odd cols
		fmt = fmt " %*s" # write_bar
		if (cons) {
			fmt = fmt fgreset "|" cyan "%-*s" # read_bar
		} else {
			fmt = fmt "|%-*s" # read_bar
		}
		fmtsz += 1 + bar_size + 1 + bar_size
		fmt = fmt " %-" dsz "s" # READ(OUT) column
		fmtsz += 1 + dsz
		fmt = substr(fmt, 2) # Trim leading space
		fmtsz -= 1
		fmt = fmt (cons ? fgreset : "") "\n"

		if (!raw_view) {
			clear_buffer()
			buffer_add_header()
			if (!output_json) print_buffer()
		}
	}

	######################################## FUNCTIONS

	function _systime() { return srand() }
	function buffer_add(text) { BUFFER = BUFFER text }
	function print_buffer() { printf "%s", BUFFER; fflush() }

	function clear_data()
	{
		delete _keys

		delete key_read
		delete key_write
	}

	function clear_buffer()
	{
		clear_data()

		BUFFER = ""
		if (output_json) return
		buffer_add(sprintf("\033[H\033[J"))
	}

	function buffer_add_header()
	{
		if (output_json) return
		buffer_add(sprintf("Interval: %-*s %31s\n",
			fmtsz - 9 - 2 - 31,
			sprintf("%.3f", interval) "s",
			strftime("%c", _systime())))
				#  9 = "Interval:"
				#  2 = number of spaces
				# 31 = %31s date
		prefix = cons ? inv green : inv bold
		suffix = cons ? fgreset noinv : noinv nobold
		buffer_add(sprintf(prefix fmt suffix, view,
			"TOTAL", "WRITE(IN)", bar_size, "", bar_size, "",
			"READ(OUT)"))
	}

	function parse_line()
	{
		# ST: CTLDATA
		sub(/\r$/, "")
		if (match($0, /[^[:space:][:digit:]][[:digit:]]+ \[sum\]/)) {
			$0 = substr($0, 1, RSTART) " " substr($0, RSTART + 1)
		}

		if (view == "SERVER") {
			key = no_names ? $1 : $NF
		} else {
			key = $1
		}

		read_bytes = write_bytes = 0
		if (view == "SERVER") {
			# NB: KiB/s -> B/interval
			read_bytes = $3 * 1024 * interval
			write_bytes = $2 * 1024 * interval
		} else {
			delete _props
			$0 = substr($0, length(key) + 1)
			while (match($0, /^ *[^ ]+ \[[^\]]+\]/)) {
				kprop = substr($2, 2, length($2) - 2)
				value = $1
				_props[kprop] = value
				$0 = substr($0, RLENGTH + 1)
			}
			read_bytes = int(_props["B-rd"])
			write_bytes = int(_props["B-wr"])
		}
		if (read_bytes + write_bytes < 1) return 0

		#
		# ST: OPS
		#

		_keys[key]
		if (view == "SERVER") {
			key_read["Sum:"] += read_bytes
			key_write["Sum:"] += write_bytes
		}
		key_read[key] = read_bytes
		key_write[key] = write_bytes

		return 1
	}

	function humanize(value,        raw, n, suffix, suffixes)
	{
		raw = value
		n = split(",K,M,G,T,E", suffixes, /,/)
		for (suffix = 1; suffix <= n; suffix++) {
			if (int(value) < 1024) break
			value /= 1024
		}
		if (v ~ /\./) sub(/\.?0+$/, "", v)
		value = sprintf("%'"'"'.2f%sB/s", value, suffixes[suffix])
		return value
	}

	function _asort(src, dest,        k, nitems, i, val)
	{
		k = nitems = 0
		for (i in src) dest[++nitems] = src[i]
		for (i = 1; i <= nitems; k = i++) {
			val = dest[i]
			while ((k > 0) && (dest[k] > val)) {
				dest[k+1] = dest[k]; k--
			}
			dest[k+1] = val
		}
		return nitems
	}

	function json_add(json, key, format, value)
	{
		return json (length(json) < 2 ? "" : ",") \
			sprintf("\"%s\":" format, key, value)
	}

	function json_add_str(json, key, value)
	{
		return json_add(json, key, "\"%s\"", value)
	}

	function json_add_uint(json, key, value)
	{
		return json_add(json, key, "%u", value)
	}

	function json_add_prec(json, key, precision, value,        x)
	{
		x = sprintf("%.*f", precision, value)
		if (x ~ /\./) sub(/\.?0+$/, "", x)
		return json_add(json, key, "%s", x)
	}

	function json_add_float(json, key, value)
	{
		return json_add_prec(json, key, 12, value)
	}

	function sample_check()
	{
		if (nsamples > 0 && --samples_left < 1) {
			system(sprintf("kill %d > /dev/null 2>&1", bpid))
			exit
		}
	}

	function process_view(curview,
		cred_read, read_bar, read_bar_pct, read_rate, read_total,
		cred_write, write_bar, write_bar_pct, write_rate, write_total,
		i, n, r, v, _keys_sorted, table_rows, cred)
	{
		if (output_json && in_summary) {
			in_summary = 0
			if (nsamples != 1) return
		}

		read_total = key_read["Sum:"]
		read_rate = read_total / interval
		read_bar = ""

		write_total = key_write["Sum:"]
		write_rate = write_total / interval
		write_bar = ""

		if (output_json) {
			json_out = ""
			json_out = json_add_uint(json_out, "time", tm)
			json_out = json_add_str(json_out,
				"ident", "total_" curview)
			json_out = json_add_uint(json_out,
				"total_bytes", read_total + write_total)
			json_out = json_add_float(json_out,
				"total_rate", read_rate + write_rate)
			json_out = json_add_uint(json_out,
				"read_bytes", read_total)
			json_out = json_add_float(json_out,
				"read_rate", read_rate)
			json_out = json_add_uint(json_out,
				"write_bytes", write_total)
			json_out = json_add_float(json_out,
				"write_rate", write_rate)
			buffer_add("{" json_out "}\n")
		} else {
			# ST: VIEWS
			buffer_add(sprintf(fmt, "total",
				humanize(write_rate + read_rate),
				humanize(write_rate), bar_size, write_bar,
				bar_size, read_bar, humanize(read_rate)))
		}

		#
		# Decorate combined read/write values
		#
		for (cred in _keys) {
			v = int(key_read[cred]) + int(key_write[cred])
			_keys[cred] = sprintf("%99d %s", v, cred)
		}

		#
		# Print subtotals
		#
		r = 0
		n = _asort(_keys, _keys_sorted)
		table_rows = output_json ? n : rows - 4
		for (i = n; i >= 1 && r++ <= table_rows; i--) {
			cred = _keys_sorted[i]
			sub(/^ *[^ ]+ +/, "", cred) # Undecorate
			if (cred == "Sum:") continue

			cred_read = key_read[cred]
			cred_write = key_write[cred]

			read_rate = cred_read / interval
			if (read_total > 0)
				read_bar_pct = cred_read / read_total
			else
				read_bar_pct = 0
			read_bar_size = bar_size * read_bar_pct
			read_bar = sprintf("%*s", read_bar_size, "")
			gsub(/ /, "=", read_bar)
			sub(/.$/, ">", read_bar)

			write_rate = cred_write / interval
			if (write_total > 0)
				write_bar_pct = cred_write / write_total
			else
				write_bar_pct = 0
			write_bar_size = bar_size * write_bar_pct
			write_bar = sprintf("%*s", write_bar_size, "")
			gsub(/ /, "=", write_bar)
			sub(/^./, "<", write_bar)

			if (!output_json && length(cred) > vsz) {
				cred = substr(cred, 1, vsz)
			}

			if (output_json) {
				# ST: JSONDATA
				json_out = ""
				json_out = json_add_uint(json_out, "time", tm)
				json_out = json_add_str(json_out,
					"ident", curview)
				json_out = json_add_str(json_out,
					curview, cred)
				json_out = json_add_uint(json_out,
					"total_bytes", cred_read + cred_write)
				json_out = json_add_float(json_out,
					"total_rate", read_rate + write_rate)
				json_out = json_add_uint(json_out,
					"read_bytes", cred_read)
				json_out = json_add_float(json_out,
					"read_rate", read_rate)
				json_out = json_add_uint(json_out,
					"write_bytes", cred_write)
				json_out = json_add_float(json_out,
					"write_rate", write_rate)
				buffer_add("{" json_out "}\n")
			} else {
				# ST: VIEWDATA
				buffer_add(sprintf(fmt, cred,
					humanize(write_rate + read_rate),
					humanize(write_rate), bar_size,
					write_bar, bar_size, read_bar,
					humanize(read_rate)))
			}
		}
		if (i > 0) buffer_add(sprintf("%s(%d more) ... %s",
			cons ? inv bold yellow : "", i,
			cons ? noinv nobold fgreset : ""))
	}

	######################################## MAIN

	sub(/^EXIT:/, "") { exit_status = $0; next }
	NR == 1 && $1 == "spawn" && !raw_view { next }

	raw_view {
		print

		# Exit if no more samples desired
		if (/^---$/) sample_check()

		next
	}

	#
	# ST: CTLDATA
	#

	/^===/ { # Data start
		read_total = write_total = 0
		clear_buffer()
		buffer_add_header()
		next
	}

	# Data
	view == "SERVER" && /^[[:space:]]*[[:digit:]]/ { parse_line() }
	view != "SERVER" && /^[^-=[:space:]]/ { parse_line() }

	/^---$/ { # Data end
		tm = _systime()

		#
		# Process requested view
		#
		process_view(tolower(view))

		#
		# Dump information
		#
		print_buffer()
		clear_data()
		sample_check() # Exit if no more samples desired
	}

	################################################## END

	END { exit exit_status }
' # END-QUOTE

################################################################################
# END
################################################################################
# Local Variables:
# mode: sh
# tab-width: 8
# sh-basic-offset: 8
# indent-tabs-mode: t
# backward-delete-char-untabify-method: nil
# End:
